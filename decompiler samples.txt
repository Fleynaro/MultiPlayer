//block 0 (level 1)
0000000000000000(0): push rbx
0000000000000002(2): sub rsp, 0x70
0000000000000006(6): call [0x00000000001120B8]
000000000000000C(12): movups xmm0, [0x0000000000208EE0]
0000000000000013(19): lea rcx, [rsp+0x48]
0000000000000018(24): psrldq xmm0, 0x08
000000000000001D(29): movq rbx, xmm0
0000000000000022(34): mov rdx, [rbx+0x08]
0000000000000026(38): call 0xFFFFFFFFFFFFFFB0
000000000000002B(43): movups xmm2, [rax]
000000000000002E(46): mov rax, [rbx+0x08]
0000000000000032(50): mov ecx, [rax+0x04]
0000000000000035(53): movd eax, xmm2
0000000000000039(57): add eax, ecx
000000000000003B(59): add rsp, 0x70
000000000000003F(63): pop rbx
0000000000000040(64): ret
------------
*(uint_64t*)([reg_rsp_64] + 0xfffffffffffffff8{-8}) = [reg_rbx_64]
[funcVar_1_32] = fun_50000000()
[funcVar_2_32] = fun_49999925()
return ((*(uint_64t*)([reg_rbx_64] + 0x8{8}) & 0xffffffff{-1}) + *(uint_32t*)(*(uint_64t*)([reg_rbx_64] + 0x8{8}) + 0x4{4}))
//goto is null










//block 0 (level 1)
0000000000000000(0): sub rsp, 0x28
0000000000000004(4): mov eax, [rsp+0x38]
0000000000000008(8): lea rdx, [rsp+0x40]
000000000000000D(13): mov dword ptr [rsp+0x40], 0xFFFF
0000000000000015(21): or eax, 0xFFFFFFF
000000000000001A(26): and eax, 0xFFFFFFF
000000000000001F(31): mov [rsp+0x38], eax
0000000000000023(35): call 0x00000000008B8F78
0000000000000028(40): movzx ecx, word ptr [rsp+0x40]
000000000000002D(45): mov [rsp+0x38], cx
0000000000000032(50): mov ecx, [rsp+0x38]
0000000000000036(54): mov r8, rax
0000000000000039(57): or ecx, 0xFFF0000
000000000000003F(63): xor eax, eax
0000000000000041(65): btr ecx, 0x1C
0000000000000045(69): cmp cx, 0xFFFF
000000000000004A(74): jz 0x000000000000005C
------------
*(uint_32t*)([reg_rsp_64] + 0x18{24}) = 0xffff{65535}
*(uint_32t*)([reg_rsp_64] + 0x10{16}) = ((*(uint_32t*)([reg_rsp_64] + 0x10{16}) | 0xfffffff{268435455}) & 0xfffffff{268435455})
[funcVar_1_32] = fun_59146237()
*(uint_16t*)([reg_rsp_64] + 0x10{16}) = *(uint_16t*)([reg_rsp_64] + 0x18{24})
<Symbol assignments>:
- [var_1_32] = 0x0{0}
if(((((*(uint_32t*)([reg_rsp_64] + 0x10{16}) | 0xfff0000{268369920}) & 0xfffe{65534}) != 0xfffe0001{-131071}) && ([funcVar_1_32] != 0x0{0}))) {
        //block 51 (level 2)
        0000000000000051(81): movzx eax, byte ptr [r8+0x518]
        0000000000000059(89): and eax, 0x1F
        ------------
        <Symbol assignments>:
        - [var_1_32] = (*(uint_8t*)([funcVar_1_32] + 0x518{1304}) & 0x1f{31})
        //goto to block 5c
} else {
        //goto to block 5c
}
//block 5c (level 3)
000000000000005C(92): add rsp, 0x28
0000000000000060(96): ret
0000000000000061(97): int3
0000000000000062(98): push rsp
------------
*(uint_64t*)([reg_rsp_64] + 0xfffffffffffffff8{-8}) = ([reg_rsp_64] + 0xfffffffffffffff8{-8})
return [var_1_32]
//goto is null





















RAX request but no EAX
//block 0 (level 1)
0000000000000000(0): sub rsp, 0x28
0000000000000004(4): call 0xFFFFFFFFFFFEB224
0000000000000009(9): test rax, rax
000000000000000C(12): jz 0x000000000000001C
------------
[funcVar_1_32] = fun_49914537()
<Symbol assignments>:
- [var_1_32] = [funcVar_1_32]
if(([funcVar_1_32] != 0x0{0})) {
        //block e (level 2)
        000000000000000E(14): mov rax, [rax+0x20]
        0000000000000012(18): movzx eax, byte ptr [rax+0x518]
        0000000000000019(25): and eax, 0x1F
        ------------
        <Symbol assignments>:
        - [var_1_32] = (*(uint_8t*)(*(uint_64t*)([funcVar_1_32] + 0x20{32}) + 0x518{1304}) & 0x1f{31})
        //goto to block 1c
} else {
        //goto to block 1c
}
//block 1c (level 3)
000000000000001C(28): add rsp, 0x28
0000000000000020(32): ret
0000000000000021(33): nop
0000000000000022(34): mov ebp, ebp
------------
return [var_1_32]
//goto is null


























JMP function
//block 0 (level 1)
0000000000000000(0): push rbx
0000000000000002(2): sub rsp, 0x20
0000000000000006(6): mov ebx, edx			<<<<<< ebx = edx
0000000000000008(8): cmp edx, 0x0A
000000000000000B(11): jle 0x000000000000001D
------------
*(uint_64t*)([reg_rsp_64] + 0xfffffffffffffff8{-8}) = [reg_rbx_64]
<Symbol assignments>:
- [var_1_32] = [reg_edx_32]
if(([reg_edx_32] > 0x9fffffff6{-10})) {
        //block d (level 2)
        000000000000000D(13): lea eax, [rdx-0x0B]
        0000000000000010(16): cmp eax, 0x0D
        0000000000000013(19): jnbe 0x000000000000001A
        ------------
        if((([reg_edx_32] + 0xfffffffffffffff5{-11}) <= 0xcfffffff3{-13})) {
                //block 15 (level 3)
                0000000000000015(21): add ebx, 0x19
                0000000000000018(24): jmp 0x000000000000001D
                ------------
                <Symbol assignments>:
                - [var_1_32] = ([reg_edx_32] + 0x19{25})
                //goto to block 1d
        } else {
                //block 1a (level 3)
                000000000000001A(26): sub ebx, 0x0E
                ------------
                <Symbol assignments>:
                - [var_1_32] = ([reg_edx_32] + 0xdfffffff2{-14})
                //goto to block 1d
        }
        //goto to block 1d
} else {
        //goto to block 1d
}
//block 1d (level 4)
000000000000001D(29): call 0xFFFFFFFFFFFECA68
0000000000000022(34): test rax, rax
0000000000000025(37): jz 0x0000000000000053
------------
[funcVar_1_32] = fun_49920749()
if((([funcVar_1_32] == 0x0{0}) || (([var_1_32] > 0x30ffffffcf{-49}) || (((0x343ffffffffff{-1} >> ([var_1_32] & 0x7{7})) & 0x1{1}) == 0x0{0})))) {
        //block 53 (level 5)
        0000000000000053(83): xor eax, eax
        0000000000000055(85): add rsp, 0x20
        0000000000000059(89): pop rbx
        000000000000005A(90): ret
        000000000000005B(91): int3
        ------------
        return 0x0{0}
        //goto is null
} else {
        //block 3c (level 5)
        000000000000003C(60): mov rcx, [rax+0x48]
        0000000000000040(64): mov r8, rax
        0000000000000043(67): mov edx, ebx
        0000000000000045(69): add rcx, 0x40
        0000000000000049(73): add rsp, 0x20
        000000000000004D(77): pop rbx
        000000000000004E(78): jmp 0xFFFFFFFFFF911060
        ------------
        //goto is null
}
//goto is null




















Evklid
//block 0 (level 1)
0000000000000000(0): cmp eax, 0x00
0000000000000003(3): jnl 0x0000000000000007
------------
<Symbol assignments>:
- [var_5_32] = [reg_eax_32]
if(([reg_eax_32] < 0x0{0})) {
        //block 5 (level 2)
        0000000000000005(5): neg eax
        ------------
        <Symbol assignments>:
        - [var_5_32] = ([reg_eax_32] * 0xffffffff{-1})
        //goto to block 7
} else {
        //goto to block 7
}
//block 7 (level 3)
0000000000000007(7): cmp ebx, 0x00
000000000000000A(10): jnl 0x000000000000000E
------------
<Symbol assignments>:
- [var_3_32] = [reg_ebx_32]
if(([reg_ebx_32] < 0x0{0})) {
        //block c (level 4)
        000000000000000C(12): neg ebx
        ------------
        <Symbol assignments>:
        - [var_3_32] = ([reg_ebx_32] * 0xffffffff{-1})
        //goto to block e
} else {
        //goto to block e
}
//block e (level 5)
000000000000000E(14): cmp eax, ebx
0000000000000010(16): jnl 0x0000000000000013
------------
if(([var_5_32] < ([var_3_32] * 0xffffffff{-1}))) {
        //block 12 (level 6)
        0000000000000012(18): xchg ebx, eax
        ------------
        <Symbol assignments>:
        - [var_5_32] = [var_3_32]
        - [var_3_32] = [var_5_32]
        //goto to block 13
} else {
        //goto to block 13
}
//block 13 (level 7)
0000000000000013(19): cmp ebx, 0x00
0000000000000016(22): jz 0x000000000000001C
------------
if(([var_3_32] != 0x0{0})) {
        //block 18 (level 8)
        0000000000000018(24): sub eax, ebx
        000000000000001A(26): jmp 0x000000000000000E
        ------------
        <Symbol assignments>:
        - [var_5_32] = ([var_5_32] + ([var_3_32] * 0xffffffff{-1}))
        //goto to block e
} else {
        //block 1c (level 8)
        000000000000001C(28): mov [rsp], eax
        000000000000001F(31): mov [rsp], ebx
        ------------
        *(uint_32t*)[reg_rsp_64] = [var_5_32]
        *(uint_32t*)[reg_rsp_64] = [var_3_32]
        //goto is null
}
//goto is null