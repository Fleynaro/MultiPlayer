/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef DataTypeManagerService_H
#define DataTypeManagerService_H

#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include "datatype_types.h"

namespace ghidra { namespace datatype {

#ifdef _MSC_VER
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

class DataTypeManagerServiceIf {
 public:
  virtual ~DataTypeManagerServiceIf() {}
  virtual void pull(std::vector<SDataTypeBase> & _return) = 0;
  virtual void pullTypedefs(std::vector<SDataTypeTypedef> & _return, const HashMap& hashmap) = 0;
  virtual void pullStructures(std::vector<SDataTypeStructure> & _return, const HashMap& hashmap) = 0;
  virtual void pullEnums(std::vector<SDataTypeEnum> & _return, const HashMap& hashmap) = 0;
  virtual void push(const std::vector<SDataType> & types) = 0;
  virtual void pushTypedefs(const std::vector<SDataTypeTypedef> & typedefs) = 0;
  virtual void pushStructures(const std::vector<SDataTypeStructure> & structures) = 0;
  virtual void pushEnums(const std::vector<SDataTypeEnum> & enums) = 0;
};

class DataTypeManagerServiceIfFactory {
 public:
  typedef DataTypeManagerServiceIf Handler;

  virtual ~DataTypeManagerServiceIfFactory() {}

  virtual DataTypeManagerServiceIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(DataTypeManagerServiceIf* /* handler */) = 0;
};

class DataTypeManagerServiceIfSingletonFactory : virtual public DataTypeManagerServiceIfFactory {
 public:
  DataTypeManagerServiceIfSingletonFactory(const ::apache::thrift::stdcxx::shared_ptr<DataTypeManagerServiceIf>& iface) : iface_(iface) {}
  virtual ~DataTypeManagerServiceIfSingletonFactory() {}

  virtual DataTypeManagerServiceIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(DataTypeManagerServiceIf* /* handler */) {}

 protected:
  ::apache::thrift::stdcxx::shared_ptr<DataTypeManagerServiceIf> iface_;
};

class DataTypeManagerServiceNull : virtual public DataTypeManagerServiceIf {
 public:
  virtual ~DataTypeManagerServiceNull() {}
  void pull(std::vector<SDataTypeBase> & /* _return */) {
    return;
  }
  void pullTypedefs(std::vector<SDataTypeTypedef> & /* _return */, const HashMap& /* hashmap */) {
    return;
  }
  void pullStructures(std::vector<SDataTypeStructure> & /* _return */, const HashMap& /* hashmap */) {
    return;
  }
  void pullEnums(std::vector<SDataTypeEnum> & /* _return */, const HashMap& /* hashmap */) {
    return;
  }
  void push(const std::vector<SDataType> & /* types */) {
    return;
  }
  void pushTypedefs(const std::vector<SDataTypeTypedef> & /* typedefs */) {
    return;
  }
  void pushStructures(const std::vector<SDataTypeStructure> & /* structures */) {
    return;
  }
  void pushEnums(const std::vector<SDataTypeEnum> & /* enums */) {
    return;
  }
};


class DataTypeManagerService_pull_args {
 public:

  DataTypeManagerService_pull_args(const DataTypeManagerService_pull_args&);
  DataTypeManagerService_pull_args& operator=(const DataTypeManagerService_pull_args&);
  DataTypeManagerService_pull_args() {
  }

  virtual ~DataTypeManagerService_pull_args() throw();

  bool operator == (const DataTypeManagerService_pull_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DataTypeManagerService_pull_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataTypeManagerService_pull_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataTypeManagerService_pull_pargs {
 public:


  virtual ~DataTypeManagerService_pull_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DataTypeManagerService_pull_result__isset {
  _DataTypeManagerService_pull_result__isset() : success(false) {}
  bool success :1;
} _DataTypeManagerService_pull_result__isset;

class DataTypeManagerService_pull_result {
 public:

  DataTypeManagerService_pull_result(const DataTypeManagerService_pull_result&);
  DataTypeManagerService_pull_result& operator=(const DataTypeManagerService_pull_result&);
  DataTypeManagerService_pull_result() {
  }

  virtual ~DataTypeManagerService_pull_result() throw();
  std::vector<SDataTypeBase>  success;

  _DataTypeManagerService_pull_result__isset __isset;

  void __set_success(const std::vector<SDataTypeBase> & val);

  bool operator == (const DataTypeManagerService_pull_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const DataTypeManagerService_pull_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataTypeManagerService_pull_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DataTypeManagerService_pull_presult__isset {
  _DataTypeManagerService_pull_presult__isset() : success(false) {}
  bool success :1;
} _DataTypeManagerService_pull_presult__isset;

class DataTypeManagerService_pull_presult {
 public:


  virtual ~DataTypeManagerService_pull_presult() throw();
  std::vector<SDataTypeBase> * success;

  _DataTypeManagerService_pull_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DataTypeManagerService_pullTypedefs_args__isset {
  _DataTypeManagerService_pullTypedefs_args__isset() : hashmap(false) {}
  bool hashmap :1;
} _DataTypeManagerService_pullTypedefs_args__isset;

class DataTypeManagerService_pullTypedefs_args {
 public:

  DataTypeManagerService_pullTypedefs_args(const DataTypeManagerService_pullTypedefs_args&);
  DataTypeManagerService_pullTypedefs_args& operator=(const DataTypeManagerService_pullTypedefs_args&);
  DataTypeManagerService_pullTypedefs_args() {
  }

  virtual ~DataTypeManagerService_pullTypedefs_args() throw();
  HashMap hashmap;

  _DataTypeManagerService_pullTypedefs_args__isset __isset;

  void __set_hashmap(const HashMap& val);

  bool operator == (const DataTypeManagerService_pullTypedefs_args & rhs) const
  {
    if (!(hashmap == rhs.hashmap))
      return false;
    return true;
  }
  bool operator != (const DataTypeManagerService_pullTypedefs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataTypeManagerService_pullTypedefs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataTypeManagerService_pullTypedefs_pargs {
 public:


  virtual ~DataTypeManagerService_pullTypedefs_pargs() throw();
  const HashMap* hashmap;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DataTypeManagerService_pullTypedefs_result__isset {
  _DataTypeManagerService_pullTypedefs_result__isset() : success(false) {}
  bool success :1;
} _DataTypeManagerService_pullTypedefs_result__isset;

class DataTypeManagerService_pullTypedefs_result {
 public:

  DataTypeManagerService_pullTypedefs_result(const DataTypeManagerService_pullTypedefs_result&);
  DataTypeManagerService_pullTypedefs_result& operator=(const DataTypeManagerService_pullTypedefs_result&);
  DataTypeManagerService_pullTypedefs_result() {
  }

  virtual ~DataTypeManagerService_pullTypedefs_result() throw();
  std::vector<SDataTypeTypedef>  success;

  _DataTypeManagerService_pullTypedefs_result__isset __isset;

  void __set_success(const std::vector<SDataTypeTypedef> & val);

  bool operator == (const DataTypeManagerService_pullTypedefs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const DataTypeManagerService_pullTypedefs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataTypeManagerService_pullTypedefs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DataTypeManagerService_pullTypedefs_presult__isset {
  _DataTypeManagerService_pullTypedefs_presult__isset() : success(false) {}
  bool success :1;
} _DataTypeManagerService_pullTypedefs_presult__isset;

class DataTypeManagerService_pullTypedefs_presult {
 public:


  virtual ~DataTypeManagerService_pullTypedefs_presult() throw();
  std::vector<SDataTypeTypedef> * success;

  _DataTypeManagerService_pullTypedefs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DataTypeManagerService_pullStructures_args__isset {
  _DataTypeManagerService_pullStructures_args__isset() : hashmap(false) {}
  bool hashmap :1;
} _DataTypeManagerService_pullStructures_args__isset;

class DataTypeManagerService_pullStructures_args {
 public:

  DataTypeManagerService_pullStructures_args(const DataTypeManagerService_pullStructures_args&);
  DataTypeManagerService_pullStructures_args& operator=(const DataTypeManagerService_pullStructures_args&);
  DataTypeManagerService_pullStructures_args() {
  }

  virtual ~DataTypeManagerService_pullStructures_args() throw();
  HashMap hashmap;

  _DataTypeManagerService_pullStructures_args__isset __isset;

  void __set_hashmap(const HashMap& val);

  bool operator == (const DataTypeManagerService_pullStructures_args & rhs) const
  {
    if (!(hashmap == rhs.hashmap))
      return false;
    return true;
  }
  bool operator != (const DataTypeManagerService_pullStructures_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataTypeManagerService_pullStructures_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataTypeManagerService_pullStructures_pargs {
 public:


  virtual ~DataTypeManagerService_pullStructures_pargs() throw();
  const HashMap* hashmap;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DataTypeManagerService_pullStructures_result__isset {
  _DataTypeManagerService_pullStructures_result__isset() : success(false) {}
  bool success :1;
} _DataTypeManagerService_pullStructures_result__isset;

class DataTypeManagerService_pullStructures_result {
 public:

  DataTypeManagerService_pullStructures_result(const DataTypeManagerService_pullStructures_result&);
  DataTypeManagerService_pullStructures_result& operator=(const DataTypeManagerService_pullStructures_result&);
  DataTypeManagerService_pullStructures_result() {
  }

  virtual ~DataTypeManagerService_pullStructures_result() throw();
  std::vector<SDataTypeStructure>  success;

  _DataTypeManagerService_pullStructures_result__isset __isset;

  void __set_success(const std::vector<SDataTypeStructure> & val);

  bool operator == (const DataTypeManagerService_pullStructures_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const DataTypeManagerService_pullStructures_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataTypeManagerService_pullStructures_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DataTypeManagerService_pullStructures_presult__isset {
  _DataTypeManagerService_pullStructures_presult__isset() : success(false) {}
  bool success :1;
} _DataTypeManagerService_pullStructures_presult__isset;

class DataTypeManagerService_pullStructures_presult {
 public:


  virtual ~DataTypeManagerService_pullStructures_presult() throw();
  std::vector<SDataTypeStructure> * success;

  _DataTypeManagerService_pullStructures_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DataTypeManagerService_pullEnums_args__isset {
  _DataTypeManagerService_pullEnums_args__isset() : hashmap(false) {}
  bool hashmap :1;
} _DataTypeManagerService_pullEnums_args__isset;

class DataTypeManagerService_pullEnums_args {
 public:

  DataTypeManagerService_pullEnums_args(const DataTypeManagerService_pullEnums_args&);
  DataTypeManagerService_pullEnums_args& operator=(const DataTypeManagerService_pullEnums_args&);
  DataTypeManagerService_pullEnums_args() {
  }

  virtual ~DataTypeManagerService_pullEnums_args() throw();
  HashMap hashmap;

  _DataTypeManagerService_pullEnums_args__isset __isset;

  void __set_hashmap(const HashMap& val);

  bool operator == (const DataTypeManagerService_pullEnums_args & rhs) const
  {
    if (!(hashmap == rhs.hashmap))
      return false;
    return true;
  }
  bool operator != (const DataTypeManagerService_pullEnums_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataTypeManagerService_pullEnums_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataTypeManagerService_pullEnums_pargs {
 public:


  virtual ~DataTypeManagerService_pullEnums_pargs() throw();
  const HashMap* hashmap;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DataTypeManagerService_pullEnums_result__isset {
  _DataTypeManagerService_pullEnums_result__isset() : success(false) {}
  bool success :1;
} _DataTypeManagerService_pullEnums_result__isset;

class DataTypeManagerService_pullEnums_result {
 public:

  DataTypeManagerService_pullEnums_result(const DataTypeManagerService_pullEnums_result&);
  DataTypeManagerService_pullEnums_result& operator=(const DataTypeManagerService_pullEnums_result&);
  DataTypeManagerService_pullEnums_result() {
  }

  virtual ~DataTypeManagerService_pullEnums_result() throw();
  std::vector<SDataTypeEnum>  success;

  _DataTypeManagerService_pullEnums_result__isset __isset;

  void __set_success(const std::vector<SDataTypeEnum> & val);

  bool operator == (const DataTypeManagerService_pullEnums_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const DataTypeManagerService_pullEnums_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataTypeManagerService_pullEnums_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DataTypeManagerService_pullEnums_presult__isset {
  _DataTypeManagerService_pullEnums_presult__isset() : success(false) {}
  bool success :1;
} _DataTypeManagerService_pullEnums_presult__isset;

class DataTypeManagerService_pullEnums_presult {
 public:


  virtual ~DataTypeManagerService_pullEnums_presult() throw();
  std::vector<SDataTypeEnum> * success;

  _DataTypeManagerService_pullEnums_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DataTypeManagerService_push_args__isset {
  _DataTypeManagerService_push_args__isset() : types(false) {}
  bool types :1;
} _DataTypeManagerService_push_args__isset;

class DataTypeManagerService_push_args {
 public:

  DataTypeManagerService_push_args(const DataTypeManagerService_push_args&);
  DataTypeManagerService_push_args& operator=(const DataTypeManagerService_push_args&);
  DataTypeManagerService_push_args() {
  }

  virtual ~DataTypeManagerService_push_args() throw();
  std::vector<SDataType>  types;

  _DataTypeManagerService_push_args__isset __isset;

  void __set_types(const std::vector<SDataType> & val);

  bool operator == (const DataTypeManagerService_push_args & rhs) const
  {
    if (!(types == rhs.types))
      return false;
    return true;
  }
  bool operator != (const DataTypeManagerService_push_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataTypeManagerService_push_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataTypeManagerService_push_pargs {
 public:


  virtual ~DataTypeManagerService_push_pargs() throw();
  const std::vector<SDataType> * types;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataTypeManagerService_push_result {
 public:

  DataTypeManagerService_push_result(const DataTypeManagerService_push_result&);
  DataTypeManagerService_push_result& operator=(const DataTypeManagerService_push_result&);
  DataTypeManagerService_push_result() {
  }

  virtual ~DataTypeManagerService_push_result() throw();

  bool operator == (const DataTypeManagerService_push_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DataTypeManagerService_push_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataTypeManagerService_push_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataTypeManagerService_push_presult {
 public:


  virtual ~DataTypeManagerService_push_presult() throw();

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DataTypeManagerService_pushTypedefs_args__isset {
  _DataTypeManagerService_pushTypedefs_args__isset() : typedefs(false) {}
  bool typedefs :1;
} _DataTypeManagerService_pushTypedefs_args__isset;

class DataTypeManagerService_pushTypedefs_args {
 public:

  DataTypeManagerService_pushTypedefs_args(const DataTypeManagerService_pushTypedefs_args&);
  DataTypeManagerService_pushTypedefs_args& operator=(const DataTypeManagerService_pushTypedefs_args&);
  DataTypeManagerService_pushTypedefs_args() {
  }

  virtual ~DataTypeManagerService_pushTypedefs_args() throw();
  std::vector<SDataTypeTypedef>  typedefs;

  _DataTypeManagerService_pushTypedefs_args__isset __isset;

  void __set_typedefs(const std::vector<SDataTypeTypedef> & val);

  bool operator == (const DataTypeManagerService_pushTypedefs_args & rhs) const
  {
    if (!(typedefs == rhs.typedefs))
      return false;
    return true;
  }
  bool operator != (const DataTypeManagerService_pushTypedefs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataTypeManagerService_pushTypedefs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataTypeManagerService_pushTypedefs_pargs {
 public:


  virtual ~DataTypeManagerService_pushTypedefs_pargs() throw();
  const std::vector<SDataTypeTypedef> * typedefs;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataTypeManagerService_pushTypedefs_result {
 public:

  DataTypeManagerService_pushTypedefs_result(const DataTypeManagerService_pushTypedefs_result&);
  DataTypeManagerService_pushTypedefs_result& operator=(const DataTypeManagerService_pushTypedefs_result&);
  DataTypeManagerService_pushTypedefs_result() {
  }

  virtual ~DataTypeManagerService_pushTypedefs_result() throw();

  bool operator == (const DataTypeManagerService_pushTypedefs_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DataTypeManagerService_pushTypedefs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataTypeManagerService_pushTypedefs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataTypeManagerService_pushTypedefs_presult {
 public:


  virtual ~DataTypeManagerService_pushTypedefs_presult() throw();

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DataTypeManagerService_pushStructures_args__isset {
  _DataTypeManagerService_pushStructures_args__isset() : structures(false) {}
  bool structures :1;
} _DataTypeManagerService_pushStructures_args__isset;

class DataTypeManagerService_pushStructures_args {
 public:

  DataTypeManagerService_pushStructures_args(const DataTypeManagerService_pushStructures_args&);
  DataTypeManagerService_pushStructures_args& operator=(const DataTypeManagerService_pushStructures_args&);
  DataTypeManagerService_pushStructures_args() {
  }

  virtual ~DataTypeManagerService_pushStructures_args() throw();
  std::vector<SDataTypeStructure>  structures;

  _DataTypeManagerService_pushStructures_args__isset __isset;

  void __set_structures(const std::vector<SDataTypeStructure> & val);

  bool operator == (const DataTypeManagerService_pushStructures_args & rhs) const
  {
    if (!(structures == rhs.structures))
      return false;
    return true;
  }
  bool operator != (const DataTypeManagerService_pushStructures_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataTypeManagerService_pushStructures_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataTypeManagerService_pushStructures_pargs {
 public:


  virtual ~DataTypeManagerService_pushStructures_pargs() throw();
  const std::vector<SDataTypeStructure> * structures;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataTypeManagerService_pushStructures_result {
 public:

  DataTypeManagerService_pushStructures_result(const DataTypeManagerService_pushStructures_result&);
  DataTypeManagerService_pushStructures_result& operator=(const DataTypeManagerService_pushStructures_result&);
  DataTypeManagerService_pushStructures_result() {
  }

  virtual ~DataTypeManagerService_pushStructures_result() throw();

  bool operator == (const DataTypeManagerService_pushStructures_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DataTypeManagerService_pushStructures_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataTypeManagerService_pushStructures_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataTypeManagerService_pushStructures_presult {
 public:


  virtual ~DataTypeManagerService_pushStructures_presult() throw();

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DataTypeManagerService_pushEnums_args__isset {
  _DataTypeManagerService_pushEnums_args__isset() : enums(false) {}
  bool enums :1;
} _DataTypeManagerService_pushEnums_args__isset;

class DataTypeManagerService_pushEnums_args {
 public:

  DataTypeManagerService_pushEnums_args(const DataTypeManagerService_pushEnums_args&);
  DataTypeManagerService_pushEnums_args& operator=(const DataTypeManagerService_pushEnums_args&);
  DataTypeManagerService_pushEnums_args() {
  }

  virtual ~DataTypeManagerService_pushEnums_args() throw();
  std::vector<SDataTypeEnum>  enums;

  _DataTypeManagerService_pushEnums_args__isset __isset;

  void __set_enums(const std::vector<SDataTypeEnum> & val);

  bool operator == (const DataTypeManagerService_pushEnums_args & rhs) const
  {
    if (!(enums == rhs.enums))
      return false;
    return true;
  }
  bool operator != (const DataTypeManagerService_pushEnums_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataTypeManagerService_pushEnums_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataTypeManagerService_pushEnums_pargs {
 public:


  virtual ~DataTypeManagerService_pushEnums_pargs() throw();
  const std::vector<SDataTypeEnum> * enums;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataTypeManagerService_pushEnums_result {
 public:

  DataTypeManagerService_pushEnums_result(const DataTypeManagerService_pushEnums_result&);
  DataTypeManagerService_pushEnums_result& operator=(const DataTypeManagerService_pushEnums_result&);
  DataTypeManagerService_pushEnums_result() {
  }

  virtual ~DataTypeManagerService_pushEnums_result() throw();

  bool operator == (const DataTypeManagerService_pushEnums_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DataTypeManagerService_pushEnums_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataTypeManagerService_pushEnums_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataTypeManagerService_pushEnums_presult {
 public:


  virtual ~DataTypeManagerService_pushEnums_presult() throw();

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class DataTypeManagerServiceClient : virtual public DataTypeManagerServiceIf {
 public:
  DataTypeManagerServiceClient(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  DataTypeManagerServiceClient(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void pull(std::vector<SDataTypeBase> & _return);
  void send_pull();
  void recv_pull(std::vector<SDataTypeBase> & _return);
  void pullTypedefs(std::vector<SDataTypeTypedef> & _return, const HashMap& hashmap);
  void send_pullTypedefs(const HashMap& hashmap);
  void recv_pullTypedefs(std::vector<SDataTypeTypedef> & _return);
  void pullStructures(std::vector<SDataTypeStructure> & _return, const HashMap& hashmap);
  void send_pullStructures(const HashMap& hashmap);
  void recv_pullStructures(std::vector<SDataTypeStructure> & _return);
  void pullEnums(std::vector<SDataTypeEnum> & _return, const HashMap& hashmap);
  void send_pullEnums(const HashMap& hashmap);
  void recv_pullEnums(std::vector<SDataTypeEnum> & _return);
  void push(const std::vector<SDataType> & types);
  void send_push(const std::vector<SDataType> & types);
  void recv_push();
  void pushTypedefs(const std::vector<SDataTypeTypedef> & typedefs);
  void send_pushTypedefs(const std::vector<SDataTypeTypedef> & typedefs);
  void recv_pushTypedefs();
  void pushStructures(const std::vector<SDataTypeStructure> & structures);
  void send_pushStructures(const std::vector<SDataTypeStructure> & structures);
  void recv_pushStructures();
  void pushEnums(const std::vector<SDataTypeEnum> & enums);
  void send_pushEnums(const std::vector<SDataTypeEnum> & enums);
  void recv_pushEnums();
 protected:
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class DataTypeManagerServiceProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  ::apache::thrift::stdcxx::shared_ptr<DataTypeManagerServiceIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (DataTypeManagerServiceProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_pull(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_pullTypedefs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_pullStructures(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_pullEnums(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_push(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_pushTypedefs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_pushStructures(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_pushEnums(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  DataTypeManagerServiceProcessor(::apache::thrift::stdcxx::shared_ptr<DataTypeManagerServiceIf> iface) :
    iface_(iface) {
    processMap_["pull"] = &DataTypeManagerServiceProcessor::process_pull;
    processMap_["pullTypedefs"] = &DataTypeManagerServiceProcessor::process_pullTypedefs;
    processMap_["pullStructures"] = &DataTypeManagerServiceProcessor::process_pullStructures;
    processMap_["pullEnums"] = &DataTypeManagerServiceProcessor::process_pullEnums;
    processMap_["push"] = &DataTypeManagerServiceProcessor::process_push;
    processMap_["pushTypedefs"] = &DataTypeManagerServiceProcessor::process_pushTypedefs;
    processMap_["pushStructures"] = &DataTypeManagerServiceProcessor::process_pushStructures;
    processMap_["pushEnums"] = &DataTypeManagerServiceProcessor::process_pushEnums;
  }

  virtual ~DataTypeManagerServiceProcessor() {}
};

class DataTypeManagerServiceProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  DataTypeManagerServiceProcessorFactory(const ::apache::thrift::stdcxx::shared_ptr< DataTypeManagerServiceIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::apache::thrift::stdcxx::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::apache::thrift::stdcxx::shared_ptr< DataTypeManagerServiceIfFactory > handlerFactory_;
};

class DataTypeManagerServiceMultiface : virtual public DataTypeManagerServiceIf {
 public:
  DataTypeManagerServiceMultiface(std::vector<apache::thrift::stdcxx::shared_ptr<DataTypeManagerServiceIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~DataTypeManagerServiceMultiface() {}
 protected:
  std::vector<apache::thrift::stdcxx::shared_ptr<DataTypeManagerServiceIf> > ifaces_;
  DataTypeManagerServiceMultiface() {}
  void add(::apache::thrift::stdcxx::shared_ptr<DataTypeManagerServiceIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void pull(std::vector<SDataTypeBase> & _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->pull(_return);
    }
    ifaces_[i]->pull(_return);
    return;
  }

  void pullTypedefs(std::vector<SDataTypeTypedef> & _return, const HashMap& hashmap) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->pullTypedefs(_return, hashmap);
    }
    ifaces_[i]->pullTypedefs(_return, hashmap);
    return;
  }

  void pullStructures(std::vector<SDataTypeStructure> & _return, const HashMap& hashmap) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->pullStructures(_return, hashmap);
    }
    ifaces_[i]->pullStructures(_return, hashmap);
    return;
  }

  void pullEnums(std::vector<SDataTypeEnum> & _return, const HashMap& hashmap) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->pullEnums(_return, hashmap);
    }
    ifaces_[i]->pullEnums(_return, hashmap);
    return;
  }

  void push(const std::vector<SDataType> & types) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->push(types);
    }
    ifaces_[i]->push(types);
  }

  void pushTypedefs(const std::vector<SDataTypeTypedef> & typedefs) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->pushTypedefs(typedefs);
    }
    ifaces_[i]->pushTypedefs(typedefs);
  }

  void pushStructures(const std::vector<SDataTypeStructure> & structures) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->pushStructures(structures);
    }
    ifaces_[i]->pushStructures(structures);
  }

  void pushEnums(const std::vector<SDataTypeEnum> & enums) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->pushEnums(enums);
    }
    ifaces_[i]->pushEnums(enums);
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
class DataTypeManagerServiceConcurrentClient : virtual public DataTypeManagerServiceIf {
 public:
  DataTypeManagerServiceConcurrentClient(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  DataTypeManagerServiceConcurrentClient(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void pull(std::vector<SDataTypeBase> & _return);
  int32_t send_pull();
  void recv_pull(std::vector<SDataTypeBase> & _return, const int32_t seqid);
  void pullTypedefs(std::vector<SDataTypeTypedef> & _return, const HashMap& hashmap);
  int32_t send_pullTypedefs(const HashMap& hashmap);
  void recv_pullTypedefs(std::vector<SDataTypeTypedef> & _return, const int32_t seqid);
  void pullStructures(std::vector<SDataTypeStructure> & _return, const HashMap& hashmap);
  int32_t send_pullStructures(const HashMap& hashmap);
  void recv_pullStructures(std::vector<SDataTypeStructure> & _return, const int32_t seqid);
  void pullEnums(std::vector<SDataTypeEnum> & _return, const HashMap& hashmap);
  int32_t send_pullEnums(const HashMap& hashmap);
  void recv_pullEnums(std::vector<SDataTypeEnum> & _return, const int32_t seqid);
  void push(const std::vector<SDataType> & types);
  int32_t send_push(const std::vector<SDataType> & types);
  void recv_push(const int32_t seqid);
  void pushTypedefs(const std::vector<SDataTypeTypedef> & typedefs);
  int32_t send_pushTypedefs(const std::vector<SDataTypeTypedef> & typedefs);
  void recv_pushTypedefs(const int32_t seqid);
  void pushStructures(const std::vector<SDataTypeStructure> & structures);
  int32_t send_pushStructures(const std::vector<SDataTypeStructure> & structures);
  void recv_pushStructures(const int32_t seqid);
  void pushEnums(const std::vector<SDataTypeEnum> & enums);
  int32_t send_pushEnums(const std::vector<SDataTypeEnum> & enums);
  void recv_pushEnums(const int32_t seqid);
 protected:
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
  ::apache::thrift::async::TConcurrentClientSyncInfo sync_;
};

#ifdef _MSC_VER
  #pragma warning( pop )
#endif

}} // namespace

#endif
